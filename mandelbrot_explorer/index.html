<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mandelbrot Set - WebGPU</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
            max-width: 300px;
        }

        #controls h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }

        #controls div {
            margin: 8px 0;
        }

        #controls label {
            display: inline-block;
            width: 120px;
        }

        #controls input[type="range"] {
            width: 150px;
        }

        #controls button {
            margin: 5px 5px 0 0;
            padding: 6px 12px;
            background: #4CAF50;
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-size: 13px;
        }

        #controls button:hover {
            background: #45a049;
        }

        #paletteMenu {
            position: absolute;
            top: 20px;
            left: 340px;
            background: rgba(0, 0, 0, 0.95);
            padding: 10px;
            border-radius: 8px;
            color: #fff;
            display: none;
            min-width: 200px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        #paletteMenu.show {
            display: block;
        }

        .palette-option {
            padding: 8px 12px;
            margin: 4px 0;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            transition: background 0.2s;
        }

        .palette-option:hover {
            background: rgba(76, 175, 80, 0.2);
        }

        .palette-option.active {
            background: rgba(76, 175, 80, 0.4);
            border-left: 3px solid #4CAF50;
        }

        .palette-preview {
            width: 60px;
            height: 20px;
            margin-left: auto;
            border-radius: 3px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 6px;
            color: #aaa;
            font-size: 12px;
        }

        #status {
            color: #4CAF50;
            font-weight: bold;
        }

        .error {
            color: #f44336 !important;
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>

    <div id="controls">
        <h3>Mandelbrot Explorer (WebGPU)</h3>
        <div>
            <label>Iterationen:</label>
            <input type="range" id="iterations" min="100" max="5000" value="1000" step="100">
            <span id="iterVal">1000</span>
        </div>
        <div>
            <label>Zoom:</label>
            <span id="zoomVal">1.0e+0</span>
        </div>
        <div>
            <button id="resetBtn">Zurücksetzen</button>
            <button id="colorBtn">Farbpalette</button>
        </div>
        <div>
            <button id="saveBtn" style="background: #2196F3; width: 100%;">8K HEIF speichern</button>
        </div>
        <div id="iter-display" style="margin-top: 10px; color: #aaa; font-size: 12px;">Cursor: Re=0.0, Im=0.0, Iter=0</div>
        <div>
            <span id="status">Initialisiere WebGPU...</span>
        </div>
    </div>

    <div id="paletteMenu">
        <div class="palette-option active" data-scheme="0">
            <span>Klassisch</span>
            <div class="palette-preview" style="background: linear-gradient(to right, #ff0080, #00ffff, #ffff00);">
            </div>
        </div>
        <div class="palette-option" data-scheme="1">
            <span>Feuer</span>
            <div class="palette-preview" style="background: linear-gradient(to right, #000000, #ff0000, #ffff00);">
            </div>
        </div>
        <div class="palette-option" data-scheme="2">
            <span>Ozean</span>
            <div class="palette-preview" style="background: linear-gradient(to right, #000033, #0066ff, #00ffcc);">
            </div>
        </div>
        <div class="palette-option" data-scheme="3">
            <span>Ultraviolett</span>
            <div class="palette-preview" style="background: linear-gradient(to right, #1a0033, #9933ff, #ff66ff);">
            </div>
        </div>
        <div class="palette-option" data-scheme="4">
            <span>Regenbogen</span>
            <div class="palette-preview"
                style="background: linear-gradient(to right, #ff0000, #ffff00, #00ff00, #00ffff, #0000ff, #ff00ff);">
            </div>
        </div>
        <div class="palette-option" data-scheme="5">
            <span>Grayscale</span>
            <div class="palette-preview" style="background: linear-gradient(to right, #000000, #ffffff);"></div>
        </div>
        <div class="palette-option" data-scheme="6">
            <span>Sunset</span>
            <div class="palette-preview"
                style="background: linear-gradient(to right, #0f0c29, #302b63, #ff512f, #dd2476);"></div>
        </div>
        <div class="palette-option" data-scheme="7">
            <span>Forest</span>
            <div class="palette-preview"
                style="background: linear-gradient(to right, #134e0e, #2d8a1e, #a8e063, #56ab2f);"></div>
        </div>
        <div class="palette-option" data-scheme="8">
            <span>Neon</span>
            <div class="palette-preview"
                style="background: linear-gradient(to right, #00d2ff, #3a7bd5, #ff00cc, #ffff00);"></div>
        </div>
        <div class="palette-option" data-scheme="9">
            <span>Ice</span>
            <div class="palette-preview"
                style="background: linear-gradient(to right, #0a1128, #1a2980, #26d0ce, #ffffff);"></div>
        </div>
        <div class="palette-option" data-scheme="10">
            <span>Lava</span>
            <div class="palette-preview"
                style="background: linear-gradient(to right, #1a0000, #8b0000, #ff4500, #ffd700);"></div>
        </div>
        <div class="palette-option" data-scheme="11">
            <span>Purple Haze</span>
            <div class="palette-preview"
                style="background: linear-gradient(to right, #360033, #6b0c66, #d31faf, #ff66ff);"></div>
        </div>
        <div class="palette-option" data-scheme="12">
            <span>Copper</span>
            <div class="palette-preview"
                style="background: linear-gradient(to right, #000000, #3d1a00, #b87333, #ffd700);"></div>
        </div>
        <div class="palette-option" data-scheme="13">
            <span>Electric</span>
            <div class="palette-preview"
                style="background: linear-gradient(to right, #000428, #004e92, #00d4ff, #ffff00);"></div>
        </div>
        <div class="palette-option" data-scheme="14">
            <span>Jade</span>
            <div class="palette-preview"
                style="background: linear-gradient(to right, #0a1f1c, #1e5c47, #00a896, #05ffe5);"></div>
        </div>
    </div>

    <div id="info">
        Klicken zum Zoomen | Shift+Klick zum Herauszoomen | Rechte Maustaste/Trackpad zum Verschieben | Mausrad zum
        Zoomen
    </div>

    <script type="module">
        const canvas = document.getElementById('canvas');
        const statusEl = document.getElementById('status');

        let device, context, pipeline, uniformBuffer, uniformBindGroup;
        let centerX = -0.5;
        let centerY = 0.0;
        let zoom = 1.0;
        let maxIter = 1000;
        let colorScheme = 0;
        let isDragging = false;
        let lastX, lastY;

        // WebGPU Shader mit erhöhter Präzision
        const shaderCode = `
            struct Uniforms {
                resolution: vec2f,
                center: vec2f,
                zoom: f32,
                maxIterations: u32,
                colorScheme: u32,
            }

            @group(0) @binding(0) var<uniform> uniforms: Uniforms;

            fn getColor(t: f32, scheme: u32) -> vec3f {
                if (scheme == 0u) {
                    // Klassisch
                    return vec3f(
                        0.5 + 0.5 * cos(3.0 + t * 0.15),
                        0.5 + 0.5 * cos(3.0 + t * 0.15 + 2.0),
                        0.5 + 0.5 * cos(3.0 + t * 0.15 + 4.0)
                    );
                } else if (scheme == 1u) {
                    // Feuer
                    let normalized = t / 100.0;
                    return vec3f(
                        min(1.0, normalized * 2.0),
                        min(1.0, pow(normalized, 2.0) * 2.0),
                        0.0
                    );
                } else if (scheme == 2u) {
                    // Ozean
                    return vec3f(
                        0.0,
                        0.5 + 0.5 * sin(t * 0.1),
                        0.5 + 0.5 * cos(t * 0.1)
                    );
                } else if (scheme == 3u) {
                    // Ultraviolett
                    let normalized = t / 100.0;
                    return vec3f(
                        0.1 + 0.5 * sin(normalized * 3.14),
                        0.0,
                        0.3 + 0.7 * cos(normalized * 3.14)
                    );
                } else if (scheme == 4u) {
                    // Regenbogen
                    let hue = (t * 0.01) % 1.0;
                    let x = 1.0 - abs(((hue * 6.0) % 2.0) - 1.0);
                    if (hue < 0.166) {
                        return vec3f(1.0, x, 0.0);
                    } else if (hue < 0.333) {
                        return vec3f(x, 1.0, 0.0);
                    } else if (hue < 0.5) {
                        return vec3f(0.0, 1.0, x);
                    } else if (hue < 0.666) {
                        return vec3f(0.0, x, 1.0);
                    } else if (hue < 0.833) {
                        return vec3f(x, 0.0, 1.0);
                    } else {
                        return vec3f(1.0, 0.0, x);
                    }
                } else if (scheme == 5u) {
                    // Grayscale
                    let gray = (t / 100.0) % 1.0;
                    return vec3f(gray, gray, gray);
                } else if (scheme == 6u) {
                    // Sunset
                    let n = t / 80.0;
                    return vec3f(
                        0.06 + 0.94 * smoothstep(0.0, 1.0, n),
                        0.17 + 0.5 * sin(n * 3.14),
                        0.16 + 0.3 * cos(n * 1.57)
                    );
                } else if (scheme == 7u) {
                    // Forest
                    let n = (t * 0.02) % 1.0;
                    return vec3f(
                        0.08 + 0.58 * n * n,
                        0.31 + 0.35 * n,
                        0.05 + 0.14 * sin(n * 6.28)
                    );
                } else if (scheme == 8u) {
                    // Neon
                    let n = t * 0.03;
                    return vec3f(
                        0.5 + 0.5 * sin(n),
                        0.5 + 0.5 * sin(n + 2.094),
                        0.5 + 0.5 * sin(n + 4.189)
                    );
                } else if (scheme == 9u) {
                    // Ice
                    let n = t / 120.0;
                    return vec3f(
                        0.04 + 0.96 * n,
                        0.16 + 0.64 * pow(n, 1.5),
                        0.16 + 0.84 * pow(n, 0.8)
                    );
                } else if (scheme == 10u) {
                    // Lava
                    let n = t / 90.0;
                    return vec3f(
                        0.1 + 0.9 * pow(n, 0.7),
                        0.0 + 0.6 * pow(n, 2.0),
                        0.0
                    );
                } else if (scheme == 11u) {
                    // Purple Haze
                    let n = (t * 0.025) % 1.0;
                    return vec3f(
                        0.21 + 0.79 * pow(n, 0.6),
                        0.05 + 0.35 * sin(n * 3.14),
                        0.2 + 0.8 * n
                    );
                } else if (scheme == 12u) {
                    // Copper
                    let n = t / 100.0;
                    return vec3f(
                        0.24 + 0.76 * pow(n, 0.8),
                        0.10 + 0.35 * n,
                        0.0 + 0.2 * pow(n, 2.0)
                    );
                } else if (scheme == 13u) {
                    // Electric
                    let n = t * 0.04;
                    return vec3f(
                        0.0 + 1.0 * smoothstep(0.0, 1.0, sin(n)),
                        0.16 + 0.5 * sin(n * 0.7),
                        0.57 + 0.43 * cos(n * 1.3)
                    );
                } else {
                    // Jade (scheme 14)
                    let n = t / 110.0;
                    return vec3f(
                        0.04 + 0.16 * n,
                        0.12 + 0.53 * pow(n, 0.9),
                        0.11 + 0.79 * pow(n, 0.7)
                    );
                }
            }

            @vertex
            fn vertexMain(@builtin(vertex_index) vertexIndex: u32) -> @builtin(position) vec4f {
                var pos = array<vec2f, 6>(
                    vec2f(-1.0, -1.0),
                    vec2f(1.0, -1.0),
                    vec2f(-1.0, 1.0),
                    vec2f(-1.0, 1.0),
                    vec2f(1.0, -1.0),
                    vec2f(1.0, 1.0)
                );
                return vec4f(pos[vertexIndex], 0.0, 1.0);
            }

            @fragment
            fn fragmentMain(@builtin(position) fragCoord: vec4f) -> @location(0) vec4f {
                let uv = (fragCoord.xy - uniforms.resolution * 0.5) / uniforms.resolution.y;
                let scale = 3.0 / uniforms.zoom;
                
                // Hochpräzise Koordinatenberechnung
                let cx = uniforms.center.x + uv.x * scale;
                let cy = uniforms.center.y + uv.y * scale;
                
                var zx: f32 = 0.0;
                var zy: f32 = 0.0;
                var zx2: f32 = 0.0;
                var zy2: f32 = 0.0;
                var iter: f32 = 0.0;
                
                let escape_radius_sq: f32 = 256.0;
                
                for (var i: u32 = 0u; i < uniforms.maxIterations; i = i + 1u) {
                    zy = 2.0 * zx * zy + cy;
                    zx = zx2 - zy2 + cx;
                    
                    zx2 = zx * zx;
                    zy2 = zy * zy;
                    
                    let mag_sq = zx2 + zy2;
                    
                    if (mag_sq > escape_radius_sq) {
                        break;
                    }
                    
                    iter = iter + 1.0;
                }
                
                if (iter >= f32(uniforms.maxIterations)) {
                    return vec4f(0.0, 0.0, 0.0, 1.0);
                }
                
                let mag_sq = zx2 + zy2;
                let smoothIter = iter - log2(log2(mag_sq) / 2.0);
                let color = getColor(smoothIter, uniforms.colorScheme);
                
                return vec4f(color, 1.0);
            }
        `;

        async function initWebGPU() {
            if (!navigator.gpu) {
                statusEl.textContent = 'WebGPU nicht unterstützt!';
                statusEl.classList.add('error');
                return false;
            }

            try {
                const adapter = await navigator.gpu.requestAdapter();
                if (!adapter) {
                    statusEl.textContent = 'Kein WebGPU Adapter gefunden!';
                    statusEl.classList.add('error');
                    return false;
                }

                device = await adapter.requestDevice();

                context = canvas.getContext('webgpu');
                const canvasFormat = navigator.gpu.getPreferredCanvasFormat();

                context.configure({
                    device: device,
                    format: canvasFormat,
                    alphaMode: 'opaque',
                });

                const shaderModule = device.createShaderModule({
                    code: shaderCode
                });

                pipeline = device.createRenderPipeline({
                    layout: 'auto',
                    vertex: {
                        module: shaderModule,
                        entryPoint: 'vertexMain',
                    },
                    fragment: {
                        module: shaderModule,
                        entryPoint: 'fragmentMain',
                        targets: [{
                            format: canvasFormat
                        }]
                    },
                    primitive: {
                        topology: 'triangle-list',
                    },
                });

                uniformBuffer = device.createBuffer({
                    size: 32, // vec2 + vec2 + f32 + u32 + u32 + padding
                    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
                });

                uniformBindGroup = device.createBindGroup({
                    layout: pipeline.getBindGroupLayout(0),
                    entries: [{
                        binding: 0,
                        resource: {
                            buffer: uniformBuffer
                        }
                    }]
                });

                statusEl.textContent = 'Bereit';
                return true;
            } catch (e) {
                statusEl.textContent = 'WebGPU Fehler: ' + e.message;
                statusEl.classList.add('error');
                return false;
            }
        }

        function render() {
            if (!device) return;

            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const uniformData = new ArrayBuffer(32);
            const floatView = new Float32Array(uniformData);
            const uintView = new Uint32Array(uniformData);

            floatView[0] = canvas.width;
            floatView[1] = canvas.height;
            floatView[2] = centerX;
            floatView[3] = centerY;
            floatView[4] = zoom;
            uintView[5] = maxIter;
            uintView[6] = colorScheme;

            device.queue.writeBuffer(uniformBuffer, 0, uniformData);

            const commandEncoder = device.createCommandEncoder();
            const textureView = context.getCurrentTexture().createView();

            const renderPass = commandEncoder.beginRenderPass({
                colorAttachments: [{
                    view: textureView,
                    clearValue: { r: 0, g: 0, b: 0, a: 1 },
                    loadOp: 'clear',
                    storeOp: 'store',
                }]
            });

            renderPass.setPipeline(pipeline);
            renderPass.setBindGroup(0, uniformBindGroup);
            renderPass.draw(6);
            renderPass.end();

            device.queue.submit([commandEncoder.finish()]);

            document.getElementById('zoomVal').textContent = zoom.toExponential(2);
        }

        async function renderHighRes() {
            if (!device) return;

            const saveBtn = document.getElementById('saveBtn');
            const originalText = saveBtn.textContent;
            saveBtn.textContent = 'Rendere 8K...';
            saveBtn.disabled = true;

            try {
                // Feste 8K Auflösung (7680x4320)
                const width = 7680;
                const height = 4320;

                // Erstelle Canvas für High-Res Rendering
                const offscreenCanvas = new OffscreenCanvas(width, height);
                const offscreenContext = offscreenCanvas.getContext('webgpu');

                if (!offscreenContext) {
                    throw new Error('OffscreenCanvas WebGPU Context konnte nicht erstellt werden');
                }

                const canvasFormat = navigator.gpu.getPreferredCanvasFormat();

                offscreenContext.configure({
                    device: device,
                    format: canvasFormat,
                    alphaMode: 'opaque',
                });

                // Uniform Daten mit höherer Auflösung
                const uniformData = new ArrayBuffer(32);
                const floatView = new Float32Array(uniformData);
                const uintView = new Uint32Array(uniformData);

                floatView[0] = width;
                floatView[1] = height;
                floatView[2] = centerX;
                floatView[3] = centerY;
                floatView[4] = zoom;
                uintView[5] = maxIter;
                uintView[6] = colorScheme;

                device.queue.writeBuffer(uniformBuffer, 0, uniformData);

                // Rendere in höherer Auflösung
                const commandEncoder = device.createCommandEncoder();
                const textureView = offscreenContext.getCurrentTexture().createView();

                const renderPass = commandEncoder.beginRenderPass({
                    colorAttachments: [{
                        view: textureView,
                        clearValue: { r: 0, g: 0, b: 0, a: 1 },
                        loadOp: 'clear',
                        storeOp: 'store',
                    }]
                });

                renderPass.setPipeline(pipeline);
                renderPass.setBindGroup(0, uniformBindGroup);
                renderPass.draw(6);
                renderPass.end();

                device.queue.submit([commandEncoder.finish()]);

                // Warte auf Completion
                await device.queue.onSubmittedWorkDone();

                saveBtn.textContent = 'Konvertiere HEIF...';

                // Versuche HEIF/HEIC Format (Apple)
                let blob;
                let extension = 'heic';
                let mimeType = 'image/heic';

                try {
                    // Prüfe ob Browser HEIF unterstützt
                    blob = await offscreenCanvas.convertToBlob({
                        type: 'image/heic',
                        quality: 0.70
                    });

                    if (!blob || blob.size === 0) {
                        throw new Error('HEIF nicht unterstützt');
                    }
                } catch (e) {
                    // Fallback auf JPEG (bessere Kompression als PNG)
                    console.log('HEIF nicht verfügbar, verwende JPEG');
                    saveBtn.textContent = 'Konvertiere JPEG...';
                    blob = await offscreenCanvas.convertToBlob({
                        type: 'image/jpeg',
                        quality: 0.70
                    });
                    extension = 'jpg';
                    mimeType = 'image/jpeg';
                }

                if (!blob || blob.size === 0) {
                    throw new Error('Blob ist leer - Rendering fehlgeschlagen');
                }

                // Download
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `mandelbrot_8K_${width}x${height}_zoom${zoom.toExponential(2)}.${extension}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                setTimeout(() => {
                    URL.revokeObjectURL(url);
                }, 1000);

                const formatName = extension === 'heic' ? 'HEIF' : 'JPEG';
                saveBtn.textContent = `✓ ${formatName} gespeichert!`;
                setTimeout(() => {
                    saveBtn.textContent = originalText;
                    saveBtn.disabled = false;
                }, 2000);

                // Stelle normalen Canvas wieder her
                render();
            } catch (error) {
                console.error('Fehler beim Speichern:', error);
                saveBtn.textContent = 'Fehler: ' + error.message;
                saveBtn.disabled = false;
                setTimeout(() => {
                    saveBtn.textContent = originalText;
                }, 3000);
                render();
            }
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const px = (e.clientX - rect.left) / rect.width;
            const py = (e.clientY - rect.top) / rect.height;

            // Konvertiere Pixel zu Mandelbrot-Koordinaten
            const uvx = (px - 0.5) * 2.0;
            const uvy = (py - 0.5) * 2.0;
            const aspect = canvas.width / canvas.height;

            const scale = 3.0 / zoom;
            const clickX = centerX + uvx * scale * aspect / 2.0;
            const clickY = centerY + uvy * scale;

            centerX = clickX;
            centerY = clickY;

            if (e.shiftKey) {
                zoom /= 2;
            } else {
                zoom *= 2;
            }

            render();
        });

        canvas.addEventListener('mousedown', (e) => {
            // Nur mit rechter Maustaste oder mittlerer Maustaste panning
            if (e.button === 2 || e.button === 1) {
                isDragging = true;
                lastX = e.clientX;
                lastY = e.clientY;
                e.preventDefault();
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const rect = canvas.getBoundingClientRect();
                const dx = (e.clientX - lastX) / rect.width;
                const dy = (e.clientY - lastY) / rect.height;

                const aspect = canvas.width / canvas.height;
                const scale = 3.0 / zoom;

                centerX -= dx * scale * aspect;
                centerY -= dy * scale;

                lastX = e.clientX;
                lastY = e.clientY;
                render();
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // Touch-Unterstützung für Trackpads und Touchscreens
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartDist = 0;
        let touchStartZoom = 1.0;
        let touchStartCenterX = 0;
        let touchStartCenterY = 0;
        let isTouching = false;

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isTouching = true;

            if (e.touches.length === 1) {
                // Einzelner Touch für Panning
                const touch = e.touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                touchStartCenterX = centerX;
                touchStartCenterY = centerY;
            } else if (e.touches.length === 2) {
                // Zwei Finger für Zoom
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                touchStartDist = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                touchStartZoom = zoom;
                touchStartCenterX = centerX;
                touchStartCenterY = centerY;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!isTouching) return;

            if (e.touches.length === 1) {
                // Panning mit einem Finger
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const dx = (touch.clientX - touchStartX) / rect.width;
                const dy = (touch.clientY - touchStartY) / rect.height;

                const aspect = canvas.width / canvas.height;
                const scale = 3.0 / zoom;

                centerX = touchStartCenterX - dx * scale * aspect;
                centerY = touchStartCenterY - dy * scale;

                render();
            } else if (e.touches.length === 2) {
                // Pinch-to-Zoom mit zwei Fingern
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentDist = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );

                const scale = currentDist / touchStartDist;
                zoom = touchStartZoom * scale;

                render();
            }
        });

        canvas.addEventListener('touchend', (e) => {
            if (e.touches.length === 0) {
                isTouching = false;
            } else if (e.touches.length === 1) {
                // Wechsel von 2 zu 1 Finger
                const touch = e.touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                touchStartCenterX = centerX;
                touchStartCenterY = centerY;
            }
        });

        // Trackpad/Wheel Zoom
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();

            const rect = canvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) / rect.width;
            const mouseY = (e.clientY - rect.top) / rect.height;

            // Zoom-Faktor
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;

            // Berechne Mandelbrot-Koordinaten vor dem Zoom
            const uvx = (mouseX - 0.5) * 2.0;
            const uvy = (mouseY - 0.5) * 2.0;
            const aspect = canvas.width / canvas.height;
            const scale = 3.0 / zoom;
            const worldX = centerX + uvx * scale * aspect / 2.0;
            const worldY = centerY + uvy * scale;

            // Zoome
            zoom *= zoomFactor;

            // Passe Center an, damit Mausposition gleich bleibt
            const newScale = 3.0 / zoom;
            centerX = worldX - uvx * newScale * aspect / 2.0;
            centerY = worldY - uvy * newScale;

            render();
        }, { passive: false });

        document.getElementById('iterations').addEventListener('input', (e) => {
            maxIter = parseInt(e.target.value);
            document.getElementById('iterVal').textContent = maxIter;
            render();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            centerX = -0.5;
            centerY = 0.0;
            zoom = 1.0;
            render();
        });

        document.getElementById('saveBtn').addEventListener('click', () => {
            renderHighRes();
        });

        document.getElementById('colorBtn').addEventListener('click', () => {
            const menu = document.getElementById('paletteMenu');
            menu.classList.toggle('show');
        });

        // Palette Auswahl
        document.querySelectorAll('.palette-option').forEach(option => {
            option.addEventListener('click', () => {
                // Entferne active von allen
                document.querySelectorAll('.palette-option').forEach(opt => {
                    opt.classList.remove('active');
                });
                // Setze active auf gewählte Option
                option.classList.add('active');

                colorScheme = parseInt(option.dataset.scheme);
                render();

                // Schließe Menü
                document.getElementById('paletteMenu').classList.remove('show');
            });
        });

        // Schließe Menü bei Klick außerhalb
        document.addEventListener('click', (e) => {
            const menu = document.getElementById('paletteMenu');
            const btn = document.getElementById('colorBtn');
            if (!menu.contains(e.target) && e.target !== btn) {
                menu.classList.remove('show');
            }
        });

        window.addEventListener('resize', render);

        // Initialisierung
        initWebGPU().then(success => {
            if (success) {
                render();
            }
        });
    </script>
</body>

</html>